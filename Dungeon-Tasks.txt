Старые скрипты удалить в отдельной ветке, чтобы иметь возможность переключаться на старый вариант.

ОБОЗНАЧЕНИЯ:
+ Добавить/сделать.
- Убрать.
! Изменить/исправить.
? Обдумать.
* Соблюдать

БАЗОВЫЕ ТРЕБОВАНИЯ (в конце основного рефакторинга провести обзорный рефакторинг):
* Нормальные имена для пространств имен/классов/членов классов. Папки в проекте в соответствии с пространствами имен.
* Соблюдать порядок расположения членов в классах.
* Наследоваться от MonoBehaviour или ScriptableObject только там, где это действительно нужно.
* Классы для внутреннего использования в компоненте объявлять вложенными (можно как partial).
* Свойства только для нужных полей. Сериализовать поля только когда необходимо (доступ из редакторе, сохранение в JSON).

ИЕРАРХИЯ ПРОСТРАНСТВ ИМЕН (И ПАПОК В ПРОЕКТЕ):
* Application - Обертка игры (меню и прочее). Все, что не имеет отношения непосредственно к геймплею.
* Attributes
* Editor - Используется только в редакторе, в билд не идет.
	* PropertyDrawers
* Game
	*2. Control - Управляющие компоненты.
		* PlayerCharacter
	*4. Infrastructure - Инфраструктура. Все, что обеспечивает работоспособность других уровней.
		* InventorySystem
		* PlayerCharacter
	*3. Model - Предметная модель игры.
	*1. Presentation - Уровень представления.
		* PlayerCharacter
		* UI - Интерфейс пользователя. Выделим, если будет много компонентов уровня представления, не вписывающихся в UI.

- Старые пространства имен.

СОМНЕНИЯ В ПОСТРОЕНИИ ИЕРАРХИИ:
? Model.PlayerCharacter contains Mover
? ItemDetector зависит от уровня модели (Item), который находится выше в иерархии. ?! Как вариант, можно сделать просто общий детектор коллайдеров и ?+ Службу<T> получающую <Type> с коллайдеров.

СОМНЕНИЯ В НАИМЕНОВАНИИ:
? Mover not PlayerMover. Но PlayerAnimator not Animator т.к. есть Animator in UnityEngine
====================
ОБЯЗАТЕЛЬНО:

	DDD:
+ Архитектуру проекта привести в соответствие/Выделить четкую модель.

	DI:
+ Систему зависимостей для префабов, объектов на сцене.
? Через Level?

	НАИМЕНОВАНИЕ:
! Уменьшить вложенность скриптов в пространства имен (Game, Game.Model, Game.UI). Сортировку по папкам дополняющую пространства имен можно оставить.

	МОДЕЛЬ:
! Флаг о разовом показе сообщения о скором разрушении предмета нужно вынести в слот рук, так как это к нему относится, а не к предмету.
! Отделить модель инвентаря от действий около

	УРОВЕНЬ:
? Верно ли, что ссылка на Player хранится в Level?

	ИНВЕНТАРЬ:
! Сообщение о невозможности подобрать, когда инвентарь заполнен и не показывать его, если что-то все же подобрали.
! Выложенные предметы становится невозможно подсветить и подобрать, когда за ними стоит игрок.
! Названия методов (полей) во всех классах привести в соответствие. Например, относительно подбора и выбрасывания предметов.

	UI:
+ Сделать растягивание текста в сообщениях Notifier на всю ширину при отключенной картинке.
+ Вынести в отдельную сцену, после рефакторинга, которую подгружать для каждого уровня.
+ Показывать информацию о предметах в инвентаре.

	СИСТЕМА ПЕРЕДВИЖЕНИЯ:
! Когда зажата кнопка прыжка, то происходит удвоенное приземление игрока (видно в логах).
! Очень высокий прыжок, когда сбоку вплотную находится тайл (попробовать уменьшить GroundCheck).

	КОНТРОЛЛЕР:
+ Аттрибут для компактного отображения массива клавиш (когда создам его).

	РЕДАКТОР:
- Все ненужные теги после рефакторинга.
! Отсортировать слои после рефакторинга.
! FloatRange - свой редактор с ползунками
! Атрибут для размещения списков/массивов в строку. Например, указать количество элементов в строке и их ширину.

	СЦЕНА:
! Player.position.Z сделал равным 1, чтобы предметы подсвечивались, когда игрок стоит за ними. Когда отсортирую слои, тогда, возможно, вернуть в 0.

	СИСТЕМА ВЗАИМОДЕЙСТВИЯ:
+ Проверку на BlackStone и пресечение возможности взаимодействия с ним сразу.
? Backligher в ElementMouseController проверяется на null, а не проверка на BlackStone. Как правильней?
+ Сообщение: Бесполезно пытаться разрушить черный камень!
!! Вспышки в ColorBacklighter не работают.

	ТЕКСТОВЫЕ СООБЩЕНИЯ:
+ Отдельный модуль в редакторе со всеми сообщениями (из ElementMouseController...)

====================
СДЕЛАЯ, ЕСЛИ УСПЕЮ:

	ГРАФИКА:
+! Нарисовать и добавить спрайты сломанных предметов - для уведомлений о разрушении предмета подойдут идеально.
! Объединить всю графику в один тайлсет.

	ИГРОК:
- YCorrection. ! pivot.
? Направления: RightDirection. Добавить лицом к экрану/от экрана?

	АНИМАЦИИ/СОСТОЯНИЕ:
+ Анимацию прыжка конечной, переходящей в падение через время.

	РЕДАКТОР:
+ Код для Editior, чтобы выбранные спрайты для тайлов/предметов были видны как изображения, а не как поля.
+ Удобное создание уровней (расстановка тайлов) в редакторе.

	МОДЕЛЬ:
+ Можно сделать повреждения предметов/тайлов случайные в небольшом диапазоне, а не фиксированные.
+ Текстовые описания сделать более юморными.

	UNITY:
+ Сделать UpdateManager

====================
ECS:

	МОДЕЛЬ:
+ После рефакторинга проекта сделать ветку, в которой переписать все под ECS. И развивать обе ветки параллельно.
